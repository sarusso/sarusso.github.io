<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Stefano Alberto Russo's website</title>

    <!-- Bootstrap core CSS -->
    <link href="static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="static/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Kaushan+Script' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700' rel='stylesheet' type='text/css'>

    <!-- Custom styles for this template -->
    <link href="static/css/agency.css" rel="stylesheet">

  </head>

  <body id="page-top">

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="#page-top">
        Stefano Alberto Russo
        </a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <i class="fa fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav text-uppercase ml-auto">

            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="index.html#about">About</a>
            </li>
          
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="index.html#projects">Projects</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="index.html#lectures">Lectures</a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link js-scroll-trigger" href="blog.html">Blog</a>
            </li>

          </ul>
        </div>
      </div>
    </nav>

    <!-- phx6a -->

    <!-- About -->
    <section id="about" style="padding-bottom:50px">
      <div class="container">
        <div class="row">
          <div class="col-lg-12 text-center" style="padding-top:50px">
            <h3 class="section-heading" style="margin-top:20px; margin-bottom:20px">Container orchestrators, engines and runtimes: an overview</h3>
            <h5 style="margin-bottom:30px">18 January 2022</h5>
          </div>
        </div>
        <div class="row">
          <div class="col-lg-12" >
            <div style="margin:0 auto; max-width:800px">
            
            <!-------------------> 
            <!-- Introduction  -->
            <!------------------->   
            <h5 style="margin-top:30px">Introduction</h5>
            <hr>
            

            <p>
            Within the work I carried out ad INAF (the Italian National Institute for Astrophysics), where I developed a so called science plaform (<a href="https://www.ict.inaf.it/gitlab/exact/Rosetta">Rosetta</a>) to provide simplified access to complex computing and storage resourcer as HPC clusters and data-intensive systems, I had a chanche do deep dive in the container ecosystem.
            </p>
            <p>
            The complexity is astonishing. And perhaprs as any complex technolgy simplified enough to get mass adoption, a lot of details are hid when you just run a <code>docker run hello-world</code> command.</p>
            
            The schema below tries to summarize the situation as of today, and most importantly to clarify the relationships between the various moving parts.
            
            <a href="imgs/containers.png"><img src="imgs/containers.png" width="100%"></a>
  
            <p>
            <br/>
            A bunch of containers engines are not included, most notably 
            <a href="https://nabla-containers.github.io">Nabla containers</a> and
            <a href="https://github.com/NERSC/shifter">Shifter</a>.
            
            Moreover, in the transition from standalone projects ad LXC/LCD and Docker to the open container initiative (OCI) standard, the terminology got even more convoluted, and the same components can behave as two different ones depending on how it is used. A set of definitions is therefore definitely required to navigate the ecosystem.
            


            <!-------------------> 
            <!--  Definitions  -->
            <!------------------->   
            <h5 style="margin-top:40px">Definitions</h5>
            <hr>        
            
            <ul>
            <li>A container engine is a piece of software that accepts user requests, including command line options, pulls images, and from the end user's perspective runs the container [1]. 
            
            <li>A container runtime is a software component which is in charge of managine the container lifecyle: configuring its environment, running it, stopping it, and so on. You can think about them as what's inside the engine (i.e valves and pistons). 
            
            Runtimes can be firther sub-divided in two types: hig lewel and low level.
            
            <ul style="margin-top:10px"> 
            <li>high level container runtimes, or container runtime interfcaces (CRI). Following the engine analogy, you can think about them as the valves which in turn feeds the pistons.
            <li>low level container runtimes, or CRI runtimes. You can think about them as the pistons which do the heavy lifting.
            </ul>

            Also note that some engines can behave as runtimes and can be thus used from within other engines, or orchestrators.


            <li>Lastly, a container orchestrator is a software in charghe of managing set of containers across different computing reosurces, handling network and storage configurations which are under the hood delegated to the container runtimes.

             
            </ul> 
            <a href="imgs/container_single_vs_set.png"><img src="imgs/container_single_vs_set.png" width="40%" style="float: right;" ></a>
            The general concept is thus as follows:
            </p>
            <p>
            If you are running <b>single containers</b>, you will interact with a container engine, which in turn will interact with a container runtime. This leaving out the near-nonsense of engines that can behave as runtimes and thus used from within other engines, and that some engines have their runtime monolithically built-in, as Singularity.
            </p>
            <p>
            If you are instead running <b>set of containers</b>, then you will use an orchestrator. Which one to use between Docker compose, Kubernetes, Docker swarm etc. depends on the use case and deployment complexity. Moreove, this is true if we leave out a new trend of building orchestrators on top of other orchestrators (i.e. Portainer), in which case the orchesrator will interact with another orchestrator.
            </p>

            <!-------------------> 
            <!--  Engines      -->
            <!-------------------> 
            <h5 style="margin-top:40px">Engines</h5>
            <hr>
            
            <!--  Docker -->
            <h6 style="margin-top:20px">Docker</h6>
            <p>
            The container engine we all know.
            
            Being a monoholitic project in the beginning, it has since then refactored to support both the need of an open source ecosystem and architectural flexibility. At different stages, the Docker GitHub repository was renamed in Mody and the internal, built-in runtime was extrapolated as Containerd.
            </p>
            <p>
            
            Docker identified indeed for a long time many things: a container engine, a runtimne, a registry, an image format, a project and.. a company. It is a normal part of software to get refactored, however with Docker and Kubernetes this generated a bit of confusion. As of today, the Docker Engine is to be intended as an open source software for Linux, while Docker Desktop is to be intended as the freemium product of the Docker, Inc. company for Mac and Windows platforms. From Docker's product page: "Docker Desktop includes Docker Engine, Docker CLI client, Docker Build/BuildKit, Docker Compose, Docker Content Trust, Kubernetes, Docker Scan, and Credential Helper". 
            
            </p>


            <!--  Podman -->
            <h6 style="margin-top:20px">Podman</h6>
            <p>
            Podman is a daemonless container engine for developing, managing, and running OCI Containers on your Linux System. Containers can either be run as root or in rootless mode. Podman is a near drop-in replacement for the Docker which can run container in <u>userspacea</u>.
            
            On shared sytems, it is probably the best possible tradeoff betwee usability and secutory, as it allows to operate both as root and standard user. Unlike other userspace container solutions, in Podman users can become root inside the container even if outside they are standard users, which makes it extremely powerful.
            </p>
            <p>
            
            Podman has a few issues with user IDs (UID) management when running when running in rootless mode and UIDs close to 65536. For example, to allow the advanced package tool (APT) to work on Debian/Ubuntu-based containers, its UID must be reassinged not to clash with some forbidden ones [4], e.g.: <code>groupadd -g 600 _apt</code> and <code>usermod -g 600 _apt</code>. Moreover, by default the user outside the container is mapped to root inside the container, and non-root user mapped to to other UIDs [5]. Take home message: a terrific piece of software, but beware UIDs.
            </p>


            <!--  Singularity -->
            <h6 style="margin-top:20px">Singularity</h6>
            <p>
            Singularity (now Apptainer, because of you know... forks) is perhaps one of the worse container engine implementations around. It is actually to be thought of more as an environment than as a container engine. Its main problem is indeed that it does not enforce isolation between the containers and the host, levaing large portions exposed. This is not only a secutiry issue but most importantly it makes the container behavioiur susceptible of being affected by the host environmnent.
            
            <p>
            Directories as the <code>/home</code> folder, <code>/tmp</code>, <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> are all shared with the host, environment variables are exported as they are set on host, the PID namespace is not created from scratch, and the network and sockets are as well shared with the host.  Moreover, Singularity maps the user outside the continer as the same user inside it, meaning that every time a contaier is run the user UID (and name) will change inside it, making it very hard to handle permissions.
            </p>
            
            <p>Two issues opened on the former Singularity project are quite self-explainatory: <a href="https://github.com/apptainer/singularity/issues/476">Same container, different results</a> and <a href="https://github.com/apptainer/singularity/issues/3484">Python3 script fails in singularity container on one machine, but works in same container on another</a>. In both cases the iusse was due to lack between isolation between the container and the host.
            </p>
            <p>
            Singularity is perhaps one of the most evident symphthoms of the "not invented here" syndrome in the HPC world, and after having to deal with it for more than two years, I am now officialy saying it out loud: stay away from it, unless you really have to.
            </p>



            <!-------------------> 
            <!--  Runtimes (HL) -->
            <!------------------->
            <h5 style="margin-top:40px">High-level runtimes (or CRI)</h5>
            <hr>
            
            <!-- Containerd -->
            <h6 style="margin-top:20px">runC</h6>
            <p>
            Containerd is an high-level container originated from Docker, and decoupled for flexibility over the years. A defualt Docker engine installation will install containerd as well. Containerd is also the default Kubernetes runtime. Containerd uses runC as its default low-level runtime.
            </p>

            <!-- CRI-O -->
            <h6 style="margin-top:20px">CRI-O</h6>
            <p>
            CRI-O is an "implementation of the Kubernetes CRI (Container Runtime Interface) to enable using OCI (Open Container Initiative) compatible runtimes". It basically tried to fill some gaps along the Kubernetes devlopment as is now a direct competitor (if it makes sense to call it as such) to Containerd. CRI-O uses runC as its default low-level runtime as well.
            </p>

            <!-------------------> 
            <!--  Runtimes (LL) -->
            <!------------------->
            <h5 style="margin-top:40px">Low-level runtimes</h5>
            <hr>
            
            <!-- runC -->
            <h6 style="margin-top:20px">runC</h6>
            <p>
            RunC is an OCI-compatible container runtime. It implements the OCI specification and runs the container processes. RunC is called the <i>reference implementation</i> of OCI. [6]
            </p>

            <!-- gVisor -->
            <h6 style="margin-top:20px">gVisor</h6>
            <p>
            gVisor is a runtime developed by Google which implements kernel virtualization. In other words, each container has its own kernel, unlinke other container runtimes where the kernel is usually shared between the host and the containers. It allows for more security than other runtimes while allowing to share host resources wihtout pre-allocation.
            </p>

            <!-- Kata -->
            <h6 style="margin-top:20px">Kata</h6>
            <p>
            Kata containers is a runtime implementing hardware virtualization (aka: a virtual machine). The idea is to have a runtime which behave as running software cointainers but that under the hood spawn a new virtual machine and run the container inside it. It is very interesting in terms of security and hardware emulation for multi-architecture tests. On the cons side, it requires pre-allocation of resources, and in parituclar of the memory which is set by default to 2GB per container.
            </p>       


            <!-------------------> 
            <!-- Orchestrators -->
            <!------------------->
            <h5 style="margin-top:40px">Orchestrators</h5>
            <hr>
            
            <!--  Docker Compose -->
            <h6 style="margin-top:20px">Docker compose</h6>
            <p>
            Docker compose allows to define simple multi-service applications where all the containers run on the same node. It creates a dedicated network for the containers on the host from which they can all talk each others, and a <code>docker-compose.yml</code> file describes hotw to assemble them. It the simplest orchestrator, and very useful for local and simple deployments. Docker compose has support only for the Docker APIs, and Podamn can work with it by emulating Docker. <i>Warning</i>: Docker compose does not talk with a generic runtime but directly with the Docker engine, and is thus not exactly an orchestrator.
            </p>       


            <!--  Docker Swarm -->
            <h6 style="margin-top:20px">Docker Swarm</h6>
            <p>
            Docker Swarm is similar to docker compose but it can manage multi-node deployments, or on other words a cluster of Docker Engines called a swarm. An in-between solution not much used over the last years IMO. As for Docker compose, it has support only for the Docker APIs. <i>Warning</i>: Docker Swarm does not talk with a generic runtime but directly with the Docker engine, and is thus not exactly an orchestrator.
            </p>  


            <!--  Kubernetes -->
            <h6 style="margin-top:20px">Kubernetes</h6>
            <p>
            Kubernetes is the full-featured container orchestrators, supporting a variety of settings, network topologies and container runtimes. In 2021 it dropped support for Docker, which generated some panick over the internet. What it actually happend is that it dropped support for Dockershim, and nothing changed for the users. Kubernetes adds the notion of "pod" to the container ecosystem, and can support multiple container runtimes by defining pods with different settings. Mastreing Kubernetes is hard, and even an entry-level setup can take time. Kubernetes can be accessed both using a CLI and a set of REST APIs.
            </p>
            


            <!-------------------> 
            <!--  References      -->
            <!------------------->   
            <h5 style="margin-top:60px">References</h5>
            <hr>
            <p>
            Not to be intend as a scientif paper references, but just a bunch of links which helped me in understanding how all this works:
            </p>
            <ol>
            <li><a href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction">https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction</a>
            
            <li><a href="https://www.cloudsavvyit.com/10075/what-is-containerd-and-how-does-it-relate-to-docker-and-kubernetes/">https://www.cloudsavvyit.com/10075/what-is-containerd-and-how-does-it-relate-to-docker-and-kubernetes/</a> - also interesting for the story.
            <li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2018/07/OSLS_-Container-runtimes-and-standards.pdf">https://events19.linuxfoundation.org/wp-content/uploads/2018/07/OSLS_-Container-runtimes-and-standards.pdf</a>
            
            <li><a href="https://www.redhat.com/sysadmin/rootless-podman">https://www.redhat.com/sysadmin/rootless-podman</a>

            <li><a href="https://www.redhat.com/sysadmin/rootless-podman-makes-sense">https://www.redhat.com/sysadmin/rootless-podman-makes-sense</a>

            <li><a href="https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/">https://www.tutorialworks.com/difference-docker-containerd-runc-crio-oci/</a>

            
            <li><a href="https://computingforgeeks.com/docker-vs-cri-o-vs-containerd/">https://computingforgeeks.com/docker-vs-cri-o-vs-containerd/</a>
            
            
            </ol>
            
            <!-- See also bokmarks under Rosetta -->
  
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- phx6b -->

    <!-- Footer -->
    <footer>
      <div class="container">
        <div class="row">
          <div class="col-md-12">
           <p align="center">
            <span class="copyright">Copyright &copy; Stefano Alberto Russo.</span>
           </p>
          </div>
        </div>
      </div>
    </footer>


    <!-- Bootstrap core JavaScript -->
    <script src="static/jquery/jquery.min.js"></script>
    <script src="static/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Plugin JavaScript -->
    <script src="static/jquery-easing/jquery.easing.min.js"></script>

    <!-- Contact form JavaScript -->
    <script src="static/js/jqBootstrapValidation.js"></script>
    <script src="static/js/contact_me.js"></script>

    <!-- Custom scripts for this template -->
    <script src="static/js/agency.min.js"></script>

  </body>

</html>
